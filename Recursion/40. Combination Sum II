class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        
        candidates.sort() #imp 
        result = []
        m = len(candidates)


        def backtrack(start, n, temp):
            if n<0:
                return                
                #Fun Fact ğŸ§ 
                # list.sort() â†’ in-place, returns None (sortes the list but returns None) 
                # so, pmet = temp.copy().sort() is wrong, 
                # correct way is => pmet = temp.copy() then pmet.sort
                # sorted(list) â†’ returns a new sorted list

            
            if n==0:
                result.append(temp.copy())
                return
            
            for i in range(start, m):

                if(i>start and candidates[i] == candidates[i-1]): continue # i>start to avvoid error if i==0 and we do candidates[0-1]...., also candidates[i] == candidates[i-1] means to avoid duplicates and repeated member answers like [1,2,5] and [2,1,5].., also if u wondering what about 1 and 1 in [1,1,6] if we do candidates[i-1] == candidates[i] thing then this will skip, well because the i and start value changes every time so this wont happen..

                if(candidates[i]>target): break #becuse the list is sorted and if candidates[i] is greater then target then we are not going to find our answer there..
                temp.append(candidates[i])
                backtrack(i+1, n-candidates[i], temp)
                temp.pop()
        
        backtrack(0, target, [])
        return result
