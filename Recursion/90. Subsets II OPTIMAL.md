# Intuition

![image.png](https://assets.leetcode.com/users/images/c49e8e47-5eef-415b-a1da-23c50fd80a3e_1767175655.954128.png)


# Code
```python3 []
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        result = []
        nums.sort()
        def solve(start, curr):
            result.append(curr.copy()) #this is here without any condition becuse we need every recurssion state,  is a valid subset
            
            for i in range(start, len(nums)):
                if(i>start and nums[i] == nums[i-1]): #optimal , skips duplicate
                    continue

                curr.append(nums[i])
                solve(i+1, curr)
                curr.pop()
        
        solve(0, [])
        return result
            
```

# important note:
* we can solve this problem like the below but its not optimal and not right approach 
* also we can generate all the subset like the below approach then you might wonder why we are using the above approach
* its because the below approach is good for non duplicate list
* but if duplicate is involved then we must use the for loop approach as its the correct way to skip duplication and it consider every recurssion state where as the below approach considers only the base case condition that is the last recurssion state in every loop which is not right for this question 
* dont get confuess just dry run and use below for non duplication subset generation and above if duplication involve

# Code
```python3 []
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        result = []
        nums.sort()
        def solve(i, curr):
            if i==len(nums) :
                if curr not in result:
                    result.append(curr.copy())
                return
            
            # not include
            solve(i+1, curr)

            #include
            curr.append(nums[i])
            solve(i+1, curr)

            curr.pop()
        
        solve(0, [])
        return result
'''
                
