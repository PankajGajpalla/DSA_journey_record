
# Code
```cpp []
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int minK, int maxK) {
        long long ans = 0;
        int last_min = -1;
        int last_max = -1;
        int bad = -1;

        for(int i=0; i<nums.size(); i++){
            if(nums[i]<minK || nums[i]>maxK){
                bad = i;
                continue;
            }

            if(nums[i] == minK) last_min = i;
            if(nums[i] == maxK) last_max = i;
            
            int smallest = min(last_min, last_max);

            if(smallest>bad) ans += smallest-bad;
        }
        return ans;
    }
};

// Time Limit Exceeded 

// class Solution {
// public:
//     long long countSubarrays(vector<int>& nums, int minK, int maxK) {
//         int cnt=0;
//         for(int i=0; i<nums.size(); i++){
//             if(nums[i]>maxK || nums[i]<minK) continue;
//             int mini = nums[i];
//             int maxi = nums[i];
//             for(int j=i; j<nums.size(); j++){
//                 mini = min(mini, nums[j]);
//                 maxi = max(maxi, nums[j]);
//                 if(mini == minK && maxi == maxK) cnt++;
//                 if(mini<minK || maxi>maxK) break;
//             }
//         }
//         return cnt;
//     }
// };
```

# step by step execution(first see the code then go see this)
Perfect! Let's do a full step-by-step dry run for:

cpp
Copy
Edit
nums = [1, 3, 5, 2, 7, 5]
minK = 1
maxK = 5
We have 3 important pointers:

lastMin = -1

lastMax = -1

bad = -1

ans = 0

Start looping over nums:
ðŸ”¹ i = 0 â†’ nums[0] = 1

It's between [1,5], valid.

nums[i] == minK, so lastMin = 0.

nums[i] != maxK, so lastMax stays -1.

smallest = min(lastMin, lastMax) = min(0, -1) = -1

smallest is not > bad â†’ do nothing.

âœ… ans = 0

ðŸ”¹ i = 1 â†’ nums[1] = 3

It's between [1,5], valid.

nums[i] != minK â†’ lastMin stays 0.

nums[i] != maxK â†’ lastMax stays -1.

smallest = min(0, -1) = -1

smallest is not > bad â†’ do nothing.

âœ… ans = 0

ðŸ”¹ i = 2 â†’ nums[2] = 5

It's between [1,5], valid.

nums[i] == maxK â†’ lastMax = 2.

nums[i] != minK â†’ lastMin stays 0.

smallest = min(0, 2) = 0

smallest (0) > bad (-1) â†’ valid.

Add smallest - bad = 0 - (-1) = 1 to ans.

âœ… ans = 1

ðŸ”¹ i = 3 â†’ nums[3] = 2

It's between [1,5], valid.

nums[i] != minK and != maxK â†’ lastMin and lastMax stay.

smallest = min(0, 2) = 0

smallest (0) > bad (-1) â†’ valid.

Add 0 - (-1) = 1 to ans.

âœ… ans = 2

ðŸ”¹ i = 4 â†’ nums[4] = 7

It's outside [1,5] â†’ bad element.

bad = 4

lastMin, lastMax stay.

âœ… No counting now, because invalid element just happened.

âœ… ans = 2

ðŸ”¹ i = 5 â†’ nums[5] = 5

It's between [1,5], valid.

nums[i] == maxK â†’ lastMax = 5

nums[i] != minK

smallest = min(0,5) = 0

smallest (0) < bad (4) â†’ NOT valid â†’ no counting.

âœ… ans = 2

ðŸš€ Final Answer:
ini
Copy
Edit
ans = 2
âœ… Meaning, there are 2 valid subarrays where the min is 1 and the max is 5.

ðŸŽ¯ Important Points:

i	nums[i]	lastMin	lastMax	bad	smallest	ans
0	1	0	-1	-1	-1	0
1	3	0	-1	-1	-1	0
2	5	0	2	-1	0	1
3	2	0	2	-1	0	2
4	7	0	2	4	0	2
5	5	0	5	4	0	2


# not satisfied see this example as well 
nums = {7,2,1,3,4,5,2,3,1}
minK = 1
maxK = 5
Let's step-by-step apply the optimized logic! ðŸš€

We track:

lastMin = -1 â†’ last index of 1

lastMax = -1 â†’ last index of 5

bad = -1 â†’ last index where element is outside [1,5]

ans = 0

Let's go through each index:
ðŸ”¹ i = 0 â†’ nums[0] = 7

7 is out of range [1,5] â†’ bad element!

Update bad = 0

lastMin = -1, lastMax = -1

No valid subarray ending here.

âœ… ans = 0

ðŸ”¹ i = 1 â†’ nums[1] = 2

2 is valid (between 1 and 5)

Nothing to update (lastMin and lastMax stay -1)

smallest = min(-1, -1) = -1 â†’ Not > bad (0)

âœ… ans = 0

ðŸ”¹ i = 2 â†’ nums[2] = 1

1 == minK â†’ Update lastMin = 2

smallest = min(2, -1) = -1 â†’ Not > bad (0)

âœ… ans = 0

ðŸ”¹ i = 3 â†’ nums[3] = 3

3 valid

No update to lastMin or lastMax

smallest = min(2, -1) = -1 â†’ Not > bad (0)

âœ… ans = 0

ðŸ”¹ i = 4 â†’ nums[4] = 4

4 valid

No update

smallest = min(2, -1) = -1 â†’ Not > bad (0)

âœ… ans = 0

ðŸ”¹ i = 5 â†’ nums[5] = 5

5 == maxK â†’ Update lastMax = 5

smallest = min(2, 5) = 2

Now, smallest (2) > bad (0) â†’ âœ… VALID

Add smallest - bad = 2 - 0 = 2 to ans

âœ… ans = 2

ðŸ”¹ i = 6 â†’ nums[6] = 2

2 valid

No update

smallest = min(2,5) = 2

smallest (2) > bad (0) â†’ âœ… VALID

Add 2 - 0 = 2

âœ… ans = 4

ðŸ”¹ i = 7 â†’ nums[7] = 3

3 valid

No update

smallest = min(2,5) = 2

smallest (2) > bad (0) â†’ âœ… VALID

Add 2 - 0 = 2

âœ… ans = 6

ðŸ”¹ i = 8 â†’ nums[8] = 1

1 == minK â†’ Update lastMin = 8

smallest = min(8,5) = 5

smallest (5) > bad (0) â†’ âœ… VALID

Add 5 - 0 = 5

âœ… ans = 11

Final âœ…
cpp
Copy
Edit
ans = 11
ðŸŽ¯ Answer: 11 valid subarrays
ðŸ“ˆ Quick table:

i	nums[i]	lastMin	lastMax	bad	smallest	ans
0	7	-1	-1	0	-1	0
1	2	-1	-1	0	-1	0
2	1	2	-1	0	-1	0
3	3	2	-1	0	-1	0
4	4	2	-1	0	-1	0
5	5	2	5	0	2	2
6	2	2	5	0	2	4
7	3	2	5	0	2	6
8	1	8	5	0	5	11
