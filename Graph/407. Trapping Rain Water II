# explanation:
* boudary cells cants store water 
* first push all the boundary element into the queue and also mark them visited
* start bfs , every time taking the smallest height cells first from the boundary and checking the four direction of it, and in those direction checking it its a valid block and unvisited 
* and if the neighbour blocks height is less then the level that means it will get filled when flood comes..
* count it each time ..

* consider it like a tap is kept open and slowly the block(matrix with some holes) is filling up 
* as we do bfs traversal we keep finding the smallest height element and then checking its neighbour then completing the process and again after doing it with the next smalles height point
* if i was not able to explain u which i think i wasnt:) go check out the video below.........
# Code
```cpp []
class Solution {
    #define pip pair<int, pair<int, int>>

    bool isValid(int& x, int& y, int& m, int& n){
        return (x>=0 and x<m and y>=0 and y<n);
    }
public:
    int trapRainWater(vector<vector<int>>& heightMap) {
        int m = heightMap.size();
        int n = heightMap[0].size();

        if(m<3 or n<3) return 0; // needed minimum 3*3 matrix to hold water

        //step-1 push all the boudary elements into the minheap
        priority_queue<pip, vector<pip>, greater<pip>> minheap;
        vector<vector<bool>> visited(m, vector<bool>(n, false));

        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(i==0 or i==m-1 or j==0 or j==n-1){
                    minheap.push(make_pair(heightMap[i][j], make_pair(i,j)));
                    visited[i][j] = true;
                }
            }
        }

        //step 2 bfs
        int level = 0;
        int trapwater = 0;

        vector<int> dir = {-1,0,1,0,-1};

        while(!minheap.empty()){
            pip curr = minheap.top();
            minheap.pop();

            int height = curr.first;
            int x = curr.second.first;
            int y = curr.second.second;
            level = max(level, height);

            for(int i=0; i<4; i++)
            {
                int newX = x + dir[i];
                int newY = y + dir[i+1];

                if(isValid(newX, newY, m, n) and !visited[newX][newY]){
                    visited[newX][newY] = true;
                    minheap.push(make_pair(heightMap[newX][newY], make_pair(newX, newY)));

                    if(heightMap[newX][newY]<level){
                        trapwater += level-heightMap[newX][newY];
                    }
                }
            }
        }
        
        return trapwater;
    }
};
```

# for clear understanding watch this yt video:-
https://www.youtube.com/watch?v=nmY-NN4p4eI
